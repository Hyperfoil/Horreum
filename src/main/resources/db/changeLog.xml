<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog-ext
                                       http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd
                                       http://www.liquibase.org/xml/ns/dbchangelog
                                       http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd">

    <!-- This should be overridden in production by a system property -->
    <property name="horreum.db.secret" value="secret"/>
    <property name="quarkus.datasource.username" value="appuser" />

    <!-- Primary model -->
    <changeSet id="0" author="rvansa">
        <createTable tableName="dbsecret">
            <column name="passphrase" type="text" />
        </createTable>
        <insert tableName="dbsecret">
            <column name="passphrase" value="${horreum.db.secret}" />
        </insert>
        <createSequence sequenceName="hibernate_sequence" startValue="1" incrementBy="1" cacheSize="1" />
        <createTable tableName="hook">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="active" type="boolean">
                <constraints nullable="false" />
            </column>
            <column name="target" type="integer">
                <constraints nullable="false" />
            </column>
            <column name="type" type="text">
                <constraints nullable="false" />
            </column>
            <column name="url" type="text">
                <constraints nullable="false" />
            </column>
        </createTable>
        <addUniqueConstraint tableName="hook" columnNames="url, type, target" />
        <createSequence sequenceName="hook_id_seq" startValue="1" incrementBy="1" cacheSize="1" />
        <createTable tableName="run">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="data" type="jsonb">
                <constraints nullable="false" />
            </column>
            <column name="start" type="timestamp without time zone">
                <constraints nullable="false" />
            </column>
            <column name="stop" type="timestamp without time zone">
                <constraints nullable="false" />
            </column>
            <column name="description" type="text" />
            <column name="testid" type="integer">
                <constraints nullable="false" />
            </column>
            <column name="owner" type="text">
                <constraints nullable="false" />
            </column>
            <column name="access" type="integer">
                <constraints nullable="false" />
            </column>
            <column name="token" type="text" />
            <column name="trashed" type="boolean" defaultValue="false" />
        </createTable>
        <createSequence sequenceName="run_id_seq" startValue="1" incrementBy="1" cacheSize="1" />
        <createTable tableName="schema">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="uri" type="text">
                <constraints nullable="false" unique="true"/>
            </column>
            <column name="description" type="text" />
            <column name="name" type="text">
                <constraints nullable="false" unique="true" />
            </column>
            <column name="schema" type="jsonb" />
            <column name="testpath" type="text" />
            <column name="startpath" type="text" />
            <column name="stoppath" type="text" />
            <column name="descriptionpath" type="text" />
            <column name="owner" type="text">
                <constraints nullable="false" />
            </column>
            <column name="token" type="text" />
            <column name="access" type="integer">
                <constraints nullable="false" />
            </column>
        </createTable>
        <createSequence sequenceName="schema_id_seq" startValue="1" incrementBy="1" cacheSize="1" />
        <createTable tableName="schemaextractor">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="accessor" type="text">
                <constraints nullable="false" />
            </column>
            <column name="jsonpath" type="text">
                <constraints nullable="false" />
            </column>
            <column name="schema_id" type="integer">
                <constraints nullable="false" foreignKeyName="fk_extractor_schema_id" references="schema(id)"/>
            </column>
        </createTable>
        <createTable tableName="test">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="description" type="text"/>
            <column name="name" type="text">
                <constraints nullable="false" unique="true"/>
            </column>
            <column name="owner" type="text">
                <constraints nullable="false" />
            </column>
            <column name="token" type="text" />
            <column name="access" type="integer">
                <constraints nullable="false" />
            </column>
            <column name="defaultview_id" type="integer" />
            <column name="compareurl" type="text" />
        </createTable>
        <createSequence sequenceName="test_id_seq" startValue="10" incrementBy="1" cacheSize="1" />
        <createTable tableName="view">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="name" type="text">
                <constraints nullable="false"/>
            </column>
            <column name="test_id" type="integer">
                <constraints nullable="false" foreignKeyName="fk_view_test_id" references="test(id)"/>
            </column>
        </createTable>
        <addForeignKeyConstraint constraintName="fk_test_view_id"
                                 baseTableName="test" baseColumnNames="defaultview_id"
                                 referencedTableName="view" referencedColumnNames="id" />
        <createTable tableName="viewcomponent">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="accessors" type="text">
                <constraints nullable="false"/>
            </column>
            <column name="headername" type="text">
                <constraints nullable="false"/>
            </column>
            <column name="headerorder" type="integer">
                <constraints nullable="false"/>
            </column>
            <column name="render" type="text" />
            <column name="view_id" type="integer">
                <constraints nullable="false" foreignKeyName="fk_component_view_id" references="view(id)"/>
            </column>
        </createTable>
        <addUniqueConstraint tableName="viewcomponent" columnNames="view_id, headername" />
        <sql>
            GRANT USAGE ON SCHEMA public TO "${quarkus.datasource.username}";
            GRANT SELECT, INSERT, DELETE, UPDATE ON TABLE hook, run, schema, schemaextractor, test, view, viewcomponent TO "${quarkus.datasource.username}";
            GRANT ALL ON SEQUENCE hibernate_sequence, hook_id_seq, run_id_seq, schema_id_seq, test_id_seq TO "${quarkus.datasource.username}";
        </sql>
    </changeSet>

    <!-- Auto-updated read-only tables -->
    <changeSet id="1" author="rvansa">
        <createTable tableName="run_schemas">
            <column name="runid" type="integer" />
            <column name="testid" type="integer" />
            <column name="uri" type="text" />
            <column name="schemaid" type="integer" />
            <column name="prefix" type="text" />
        </createTable>
        <createProcedure>
            CREATE OR REPLACE FUNCTION before_run_delete_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_schemas WHERE runid = OLD.id;
                RETURN OLD;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION before_run_update_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_schemas WHERE runid = OLD.id;
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION after_run_update_func() RETURNS TRIGGER AS $$
            DECLARE
                v_schema text;
                v_schemaid integer;
            BEGIN
                FOR v_schema IN (SELECT jsonb_path_query(NEW.data, '$.\$schema'::jsonpath)#>>'{}') LOOP
                    v_schemaid := (SELECT id FROM schema WHERE uri = v_schema);
                    IF v_schemaid IS NOT NULL THEN
                        INSERT INTO run_schemas (runid, testid, prefix, uri, schemaid)
                        VALUES (NEW.id, NEW.testid, '$', v_schema, v_schemaid);
                    END IF;
                END LOOP;
                FOR v_schema IN (SELECT jsonb_path_query(NEW.data, '$.*.\$schema'::jsonpath)#>>'{}') LOOP
                    v_schemaid := (SELECT id FROM schema WHERE uri = v_schema);
                    IF v_schemaid IS NOT NULL THEN
                        INSERT INTO run_schemas (runid, testid, prefix, uri, schemaid)
                        VALUES (NEW.id, NEW.testid, '$.*', v_schema, v_schemaid);
                    END IF;
                END LOOP;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION before_schema_delete_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_schemas WHERE schemaid = OLD.id;
                RETURN OLD;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION before_schema_update_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_schemas WHERE schemaid = OLD.id;
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION after_schema_update_func() RETURNS TRIGGER AS $$
            BEGIN
                WITH rs AS (
                    SELECT id, owner, access, token, testid, '$' as prefix,
                    jsonb_path_query(RUN.data, '$.\$schema'::jsonpath)#>>'{}' as uri
                    FROM run
                    UNION
                    SELECT id, owner, access, token, testid, '$.*' as prefix,
                    jsonb_path_query(RUN.data, '$.*.\$schema'::jsonpath)#>>'{}' as uri
                    FROM run
                )
                INSERT INTO run_schemas
                SELECT rs.id as runid, rs.testid, rs.uri, NEW.id as schemaid, prefix
                FROM rs WHERE rs.uri = NEW.uri;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createTable tableName="view_data">
            <column name="vcid" type="integer" />
            <column name="runid" type="integer" />
            <column name="extractor_ids" type="int[]" />
            <column name="object" type="jsonb" />
        </createTable>
        <createProcedure>
            CREATE OR REPLACE FUNCTION vd_before_delete_run_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM view_data WHERE runid = OLD.runid;
                RETURN OLD;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION vd_after_insert_run_func() RETURNS TRIGGER AS $$
            BEGIN
                WITH vcs AS (
                    SELECT id, unnest(regexp_split_to_array(accessors, ';')) as aa
                    FROM viewcomponent
                )
                INSERT INTO view_data
                SELECT vcs.id as vcid, rs.runid, array_agg(se.id) as extractor_ids,
                    jsonb_object_agg(se.accessor, (CASE
                        WHEN aa like '%[]' THEN jsonb_path_query_array(run.data, (rs.prefix || se.jsonpath)::jsonpath)
                        ELSE jsonb_path_query_first(run.data, (rs.prefix || se.jsonpath)::jsonpath)
                    END)) as object
                FROM vcs
                JOIN schemaextractor se ON se.accessor = replace(aa, '[]', '')
                JOIN run_schemas rs ON rs.schemaid = se.schema_id
                JOIN run on run.id = rs.runid
                WHERE run.id = NEW.runid
                GROUP BY runid, vcid;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION vd_before_delete_extractor_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM view_data WHERE OLD.id = ANY(extractor_ids);
                RETURN OLD;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION vd_before_update_extractor_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM view_data WHERE OLD.id = ANY(extractor_ids);
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION vd_after_update_extractor_func() RETURNS TRIGGER AS $$
            BEGIN
                WITH vcs AS (
                    SELECT id, unnest(regexp_split_to_array(accessors, ';')) as aa
                    FROM viewcomponent
                )
                INSERT INTO view_data
                SELECT vcs.id as vcid, rs.runid, array_agg(se.id) as extractor_ids,
                    jsonb_object_agg(se.accessor, (CASE
                        WHEN aa like '%[]' THEN jsonb_path_query_array(run.data, (rs.prefix || se.jsonpath)::jsonpath)
                        ELSE jsonb_path_query_first(run.data, (rs.prefix || se.jsonpath)::jsonpath)
                    END)) as object
                FROM vcs
                JOIN schemaextractor se ON se.accessor = replace(aa, '[]', '')
                JOIN run_schemas rs ON rs.schemaid = se.schema_id
                JOIN run on run.id = rs.runid
                WHERE se.id = NEW.id
                GROUP BY runid, vcid;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION vd_before_delete_vc_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM view_data WHERE vcid = OLD.id;
                RETURN OLD;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION vd_before_update_vc_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM view_data WHERE vcid = OLD.id;
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION vd_after_update_vc_func() RETURNS TRIGGER AS $$
            BEGIN
                WITH vcs AS (
                    SELECT id, unnest(regexp_split_to_array(accessors, ';')) as aa
                    FROM viewcomponent
                    WHERE id = NEW.id
                )
                INSERT INTO view_data
                SELECT vcs.id as vcid, rs.runid, array_agg(se.id) as extractor_ids,
                    jsonb_object_agg(se.accessor, (CASE
                        WHEN aa like '%[]' THEN jsonb_path_query_array(run.data, (rs.prefix || se.jsonpath)::jsonpath)
                        ELSE jsonb_path_query_first(run.data, (rs.prefix || se.jsonpath)::jsonpath)
                    END)) as object
                FROM vcs
                JOIN schemaextractor se ON se.accessor = replace(aa, '[]', '')
                JOIN run_schemas rs ON rs.schemaid = se.schema_id
                JOIN run on run.id = rs.runid
                GROUP BY runid, vcid;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <!-- Triggers run with privileges of the user running the update = appuser -->
        <sql>
            GRANT select, insert, delete, update ON TABLE run_schemas, view_data TO "${quarkus.datasource.username}";
        </sql>
        <sql>
            CREATE TRIGGER before_run_delete BEFORE DELETE ON run FOR EACH ROW EXECUTE FUNCTION before_run_delete_func();
            CREATE TRIGGER before_run_update BEFORE UPDATE ON run FOR EACH ROW EXECUTE FUNCTION before_run_update_func();
            CREATE TRIGGER after_run_update AFTER INSERT OR UPDATE ON run FOR EACH ROW EXECUTE FUNCTION after_run_update_func();
            CREATE TRIGGER before_schema_delete BEFORE DELETE ON schema FOR EACH ROW EXECUTE FUNCTION before_schema_delete_func();
            CREATE TRIGGER before_schema_update BEFORE UPDATE OF uri ON schema FOR EACH ROW EXECUTE FUNCTION before_schema_update_func();
            CREATE TRIGGER after_schema_update AFTER INSERT OR UPDATE OF uri ON schema FOR EACH ROW EXECUTE FUNCTION after_schema_update_func();

            CREATE TRIGGER vd_before_delete BEFORE DELETE ON run_schemas FOR EACH ROW EXECUTE FUNCTION vd_before_delete_run_func();
            CREATE TRIGGER vd_after_insert AFTER INSERT ON run_schemas FOR EACH ROW EXECUTE FUNCTION vd_after_insert_run_func();
            CREATE TRIGGER vd_before_delete BEFORE DELETE ON schemaextractor FOR EACH ROW EXECUTE FUNCTION vd_before_delete_extractor_func();
            CREATE TRIGGER vd_before_update BEFORE UPDATE ON schemaextractor FOR EACH ROW EXECUTE FUNCTION vd_before_update_extractor_func();
            CREATE TRIGGER vd_after_update AFTER INSERT OR UPDATE ON schemaextractor FOR EACH ROW EXECUTE FUNCTION vd_after_update_extractor_func();
            CREATE TRIGGER vd_before_delete BEFORE DELETE ON viewcomponent FOR EACH ROW EXECUTE FUNCTION vd_before_delete_vc_func();
            CREATE TRIGGER vd_before_update BEFORE UPDATE OF id, accessors ON viewcomponent FOR EACH ROW EXECUTE FUNCTION vd_before_update_vc_func();
            CREATE TRIGGER vd_after_update AFTER INSERT OR UPDATE OF id, accessors ON viewcomponent FOR EACH ROW EXECUTE FUNCTION vd_after_update_vc_func();
        </sql>
        <rollback>
            DROP TRIGGER IF EXISTS before_run_delete ON run;
            DROP TRIGGER IF EXISTS before_run_update ON run;
            DROP TRIGGER IF EXISTS after_run_update ON run;
            DROP TRIGGER IF EXISTS before_schema_delete ON run;
            DROP TRIGGER IF EXISTS before_schema_update ON run;
            DROP TRIGGER IF EXISTS after_schema_update ON run;

            DROP TRIGGER IF EXISTS vd_before_delete ON run_schemas;
            DROP TRIGGER IF EXISTS vd_after_insert ON run_schemas;
            DROP TRIGGER IF EXISTS vd_before_delete ON schemaextractor;
            DROP TRIGGER IF EXISTS vd_before_update ON schemaextractor;
            DROP TRIGGER IF EXISTS vd_after_update ON schemaextractor;
            DROP TRIGGER IF EXISTS vd_before_delete ON viewcomponent;
            DROP TRIGGER IF EXISTS vd_before_update ON viewcomponent;
            DROP TRIGGER IF EXISTS vd_after_update ON viewcomponent;
        </rollback>
    </changeSet>

    <!-- Security constraints -->
    <changeSet id="2" author="rvansa">
        <sql>
            <!-- Install pgcrypto plugin -->
            CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;
        </sql>
        <createProcedure>
            <!-- Verify that what user has in horreum.userroles is correctly signed -->
            CREATE OR REPLACE FUNCTION has_role(owner TEXT) RETURNS boolean AS $$
            DECLARE
                v_passphrase TEXT;
                v_userroles TEXT;
                v_role_salt_sign TEXT;
                v_parts TEXT[];
                v_role TEXT;
                v_salt TEXT;
                v_signature TEXT;
                v_computed TEXT;
            BEGIN
                SELECT passphrase INTO v_passphrase FROM dbsecret;
                v_userroles := current_setting('horreum.userroles', true);

                IF v_userroles = '' OR v_userroles IS NULL THEN
                     RETURN 0;
                END IF;

                FOREACH v_role_salt_sign IN ARRAY regexp_split_to_array(v_userroles, ',')
                LOOP
                    v_parts := regexp_split_to_array(v_role_salt_sign, ':');
                    v_role := v_parts[1];
                    IF v_role = owner THEN
                        v_salt := v_parts[2];
                        v_signature := v_parts[3];
                        v_computed := encode(digest(v_role || v_salt || v_passphrase, 'sha256'), 'base64');
                        IF v_computed = v_signature THEN
                            RETURN 1;
                        ELSE
                            RAISE EXCEPTION 'invalid role + salt + signature';
                        END IF;
                    END IF;
                END LOOP;
                RETURN 0;
            END;
            $$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION can_view(access INTEGER, owner TEXT, token TEXT) RETURNS boolean AS $$
            BEGIN
                RETURN (
                    access = 0
                    OR (access = 1 AND has_role('viewer'))
                    OR (access = 2 AND has_role(owner) AND has_role('viewer'))
                    OR token = current_setting('horreum.token', true)
                );
            END;
            $$ LANGUAGE plpgsql STABLE;
        </createProcedure>
        <sqlFile path="policies.sql" relativeToChangelogFile="true" />
    </changeSet>

    <changeSet id="3" author="rvansa">
        <createTable tableName="variable">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="name" type="text">
                <constraints nullable="false" />
            </column>
            <column name="testid" type="integer">
                <!-- No foregin key constraint -->
                <constraints nullable="false" />
            </column>
            <column name="accessors" type="text">
                <constraints nullable="false" />
            </column>
            <column name="calculation" type="text"/>
            <column name="maxwindow" type="integer">
                <constraints nullable="false"/>
            </column>
            <column name="deviationfactor" type="double precision">
                <constraints nullable="false"/>
            </column>
            <column name="confidence" type="double precision">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <createTable tableName="datapoint">
            <column name="id" type="integer" autoIncrement="true">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="runid" type="integer">
                <!-- No foreign key constraint -->
                <constraints nullable="false" />
            </column>
            <column name="timestamp" type="timestamp">
                <constraints nullable="false" />
            </column>
            <column name="variable_id" type="integer">
                <constraints nullable="false" />
            </column>
            <column name="value" type="double precision">
                <constraints nullable="false" />
            </column>
        </createTable>
        <addForeignKeyConstraint constraintName="fk_datapoint_variable_id"
                                 baseTableName="datapoint" baseColumnNames="variable_id"
                                 referencedTableName="variable" referencedColumnNames="id" />
        <createTable tableName="change">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="confirmed" type="boolean">
                <constraints nullable="false"/>
            </column>
            <column name="description" type="text"/>
            <column name="variable_id" type="integer">
                <constraints nullable="false"/>
            </column>
            <column name="runid" type="integer">
                <constraints nullable="false"/>
            </column>
            <column name="timestamp" type="timestamp">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint constraintName="fk_change_variable_id"
                                 baseTableName="change" baseColumnNames="variable_id"
                                 referencedTableName="variable" referencedColumnNames="id" />
        <createTable tableName="watch">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="testid" type="integer">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addUniqueConstraint tableName="watch" columnNames="testid"/>
        <createTable tableName="watch_users">
            <column name="watch_id" type="integer"/>
            <column name="users" type="text" />
        </createTable>
        <addForeignKeyConstraint constraintName="fk_watch_users"
                                 baseTableName="watch_users" baseColumnNames="watch_id"
                                 referencedTableName="watch" referencedColumnNames="id" />
        <createTable tableName="watch_teams">
            <column name="watch_id" type="integer"/>
            <column name="teams" type="text" />
        </createTable>
        <addForeignKeyConstraint constraintName="fk_watch_teams"
                                 baseTableName="watch_teams" baseColumnNames="watch_id"
                                 referencedTableName="watch" referencedColumnNames="id" />
        <createTable tableName="notificationsettings">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="disabled" type="boolean" defaultValue="false">
                <constraints nullable="false"/>
            </column>
            <column name="isteam" type="boolean">
                <constraints nullable="false"/>
            </column>
            <column name="method" type="text">
                <constraints nullable="false"/>
            </column>
            <column name="name" type="text">
                <constraints nullable="false"/>
            </column>
            <column name="data" type="text" />
        </createTable>
        <sql>
            GRANT SELECT, INSERT, DELETE, UPDATE ON TABLE change, datapoint, notificationsettings, variable, watch, watch_teams, watch_users TO "${quarkus.datasource.username}";
            <!-- In case of ALL policy the USING is applied on the inserted data as well -->
            ALTER TABLE change ENABLE ROW LEVEL SECURITY;
            ALTER TABLE datapoint ENABLE ROW LEVEL SECURITY;
            ALTER TABLE notificationsettings ENABLE ROW LEVEL SECURITY;
            ALTER TABLE variable ENABLE ROW LEVEL SECURITY;
            ALTER TABLE watch ENABLE ROW LEVEL SECURITY;
            ALTER TABLE watch_teams ENABLE ROW LEVEL SECURITY;
            ALTER TABLE watch_users ENABLE ROW LEVEL SECURITY;
            CREATE POLICY change_select ON change FOR SELECT
                USING (has_role('horreum.alerting') OR exists(
                    SELECT 1 FROM run
                    WHERE run.id = runid AND can_view(run.access, run.owner, run.token)
                ));
            CREATE POLICY change_insert ON change FOR INSERT
                WITH CHECK (has_role('horreum.alerting') OR exists(
                    SELECT 1 FROM run
                    WHERE run.id = runid AND has_role(run.owner)
                ));
            CREATE POLICY change_update ON change FOR UPDATE
                USING (exists(
                    SELECT 1 FROM run
                    WHERE run.id = runid AND has_role(run.owner)
                )) WITH CHECK (has_role('tester') AND exists(
                    SELECT 1 FROM run
                    WHERE run.id = runid AND has_role(run.owner)
                ));
            CREATE POLICY change_delete ON change FOR DELETE
                USING (has_role('tester') AND exists(
                    SELECT 1 FROM run
                    WHERE run.id = runid AND has_role(run.owner)
                ));
            CREATE POLICY datapoint_select ON datapoint FOR SELECT
                USING (has_role('horreum.alerting') OR exists(
                    SELECT 1 FROM run
                    WHERE run.id = runid AND can_view(run.access, run.owner, run.token)
                ));
            CREATE POLICY datapoint_insert ON datapoint FOR INSERT WITH CHECK (has_role('horreum.alerting'));
            CREATE POLICY datapoint_update ON datapoint FOR UPDATE USING (has_role('horreum.alerting'));
            CREATE POLICY datapoint_delete ON datapoint FOR DELETE
                USING (has_role('horreum.alerting') OR exists(
                    SELECT 1 FROM run
                    WHERE run.id = runid AND has_role(run.owner)
                ));
            CREATE POLICY notificationsettings_policies ON notificationsettings FOR ALL
                USING (has_role('horreum.alerting') OR has_role(name));
            CREATE POLICY variable_select ON variable FOR SELECT
                USING (has_role('horreum.alerting') OR exists(
                    SELECT 1 FROM test
                    WHERE test.id = testid AND can_view(test.access, test.owner, test.token)
                ));
            CREATE POLICY variable_insert ON variable FOR INSERT
                WITH CHECK (has_role('horreum.alerting') OR exists(
                    SELECT 1 FROM test
                    WHERE test.id = testid AND has_role(test.owner)
                ));
            CREATE POLICY variable_update ON variable FOR UPDATE
                USING (has_role('horreum.alerting') OR exists(
                    SELECT 1 FROM test
                    WHERE test.id = testid AND has_role(test.owner)
                ));
            CREATE POLICY variable_delete ON variable FOR DELETE
                USING (has_role('horreum.alerting') OR exists(
                    SELECT 1 FROM test
                    WHERE test.id = testid AND has_role(test.owner)
                ));
            CREATE POLICY watch_select ON watch FOR SELECT USING (true);
            CREATE POLICY watch_insert ON watch FOR INSERT WITH CHECK (true);
            CREATE POLICY watch_update ON watch FOR UPDATE USING (has_role('horreum.alerting'));
            CREATE POLICY watch_delete ON watch FOR DELETE USING (has_role('horreum.alerting'));
            CREATE POLICY watch_teams_policies ON watch_teams FOR ALL USING (has_role('horreum.alerting') OR has_role(teams));
            CREATE POLICY watch_users_policies ON watch_users FOR ALL USING (has_role('horreum.alerting') OR has_role(users));
        </sql>
    </changeSet>

    <changeSet id="4" author="rvansa">
        <createTable tableName="grafana_dashboard">
            <column name="uid" type="text">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="testid" type="integer">
                <constraints nullable="false" />
            </column>
            <column name="url" type="text">
                <constraints nullable="false" />
            </column>
        </createTable>
        <createTable tableName="grafana_dashboard_variable">
            <column name="grafana_dashboard_uid" type="text">
                <constraints nullable="false" />
            </column>
            <column name="variables_id" type="integer">
                <constraints nullable="false" />
            </column>
            <column name="variables_order" type="integer">
                <constraints nullable="false" />
            </column>
        </createTable>
        <addPrimaryKey tableName="grafana_dashboard_variable" columnNames="grafana_dashboard_uid, variables_order" />
        <addForeignKeyConstraint baseTableName="grafana_dashboard_variable" baseColumnNames="grafana_dashboard_uid"
                                 constraintName="fk_grafana_dashboard_uid"
                                 referencedTableName="grafana_dashboard" referencedColumnNames="uid" />
        <addForeignKeyConstraint baseTableName="grafana_dashboard_variable" baseColumnNames="variables_id"
                                 constraintName="fk_grafana_dashboard_variables_id"
                                 referencedTableName="variable" referencedColumnNames="id" />
        <sql>
            GRANT SELECT, INSERT, DELETE, UPDATE ON TABLE grafana_dashboard, grafana_dashboard_variable TO "${quarkus.datasource.username}";
            ALTER TABLE grafana_dashboard ENABLE ROW LEVEL SECURITY;
            ALTER TABLE grafana_dashboard_variable ENABLE ROW LEVEL SECURITY;
            <!-- Anyone who could view the test/dashboard can also create it -->
            CREATE POLICY grafana_dashboard_policies ON grafana_dashboard FOR ALL
                USING (exists(
                    SELECT 1 FROM test
                    WHERE test.id = testid AND can_view(test.access, test.owner, test.token)
               ));
            CREATE POLICY grafana_dashboard_variable_policies ON grafana_dashboard_variable FOR ALL
                USING (exists(
                    SELECT 1 FROM test
                    JOIN grafana_dashboard gd ON gd.uid = grafana_dashboard_uid
                    WHERE test.id = gd.testid AND can_view(test.access, test.owner, test.token)
                ));
        </sql>
    </changeSet>
    
    <changeSet id="5" author="rvansa">
        <createTable tableName="userinfo">
            <column name="username" type="text">
                <constraints primaryKey="true" nullable="false" />
            </column>
        </createTable>
        <createTable tableName="userinfo_teams">
            <column name="username" type="text">
                <constraints nullable="false" />
            </column>
            <column name="team" type="text">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint constraintName="fk_userinfo_username"
                                 baseTableName="userinfo_teams" baseColumnNames="username"
                                 referencedTableName="userinfo" referencedColumnNames="username" />
        <addUniqueConstraint tableName="userinfo_teams" columnNames="username,team" />
        <sql>
            GRANT SELECT, INSERT, DELETE, UPDATE ON TABLE userinfo, userinfo_teams TO "${quarkus.datasource.username}";
            ALTER TABLE userinfo ENABLE ROW LEVEL SECURITY;
            ALTER TABLE userinfo_teams ENABLE ROW LEVEL SECURITY;
            CREATE POLICY userinfo_policies ON userinfo FOR ALL
                USING (has_role('horreum.alerting'));
            CREATE POLICY userinfo_teams_policies ON userinfo_teams FOR ALL
                USING (has_role('horreum.alerting'));
        </sql>
    </changeSet>

    <changeSet id="6" author="rvansa">
        <addColumn tableName="variable">
            <column name="group" type="text" />
        </addColumn>
        <addColumn tableName="variable">
            <column name="order" type="integer" defaultValue="0">
                <constraints nullable="false"/>
            </column>
        </addColumn>
    </changeSet>

    <changeSet id="7" author="rvansa">
        <dropTable tableName="grafana_dashboard_variable" />
        <createTable tableName="grafana_panel">
            <column name="id" type="integer">
                <constraints primaryKey="true" nullable="false" />
            </column>
            <column name="order" type="integer" />
            <column name="grafana_dashboard_uid" type="text">
                <constraints nullable="false" />
            </column>
        </createTable>
        <addForeignKeyConstraint constraintName="fk_grafana_panel_dashboard_uid"
                                 baseTableName="grafana_panel" baseColumnNames="grafana_dashboard_uid"
                                 referencedTableName="grafana_dashboard" referencedColumnNames="uid" />
        <createTable tableName="grafana_panel_variable">
            <column name="grafana_panel_id" type="integer" />
            <column name="variables_id" type="integer">
                <constraints nullable="false" />
            </column>
            <column name="variables_order" type="integer">
                <constraints nullable="false" />
            </column>
        </createTable>
        <addPrimaryKey tableName="grafana_panel_variable" columnNames="grafana_panel_id, variables_order" />
        <addForeignKeyConstraint baseTableName="grafana_panel_variable" baseColumnNames="grafana_panel_id"
                                 constraintName="fk_grafana_panel_id"
                                 referencedTableName="grafana_panel" referencedColumnNames="id" />
        <addForeignKeyConstraint baseTableName="grafana_panel_variable" baseColumnNames="variables_id"
                                 constraintName="fk_grafana_panel_variables_id"
                                 referencedTableName="variable" referencedColumnNames="id" />
        <sql>
            GRANT SELECT, INSERT, DELETE, UPDATE ON TABLE grafana_panel, grafana_panel_variable TO "${quarkus.datasource.username}";
            ALTER TABLE grafana_panel ENABLE ROW LEVEL SECURITY;
            ALTER TABLE grafana_panel_variable ENABLE ROW LEVEL SECURITY;
            CREATE POLICY grafana_panel_policies ON grafana_panel FOR ALL
                USING (exists(
                    SELECT 1 FROM test
                    JOIN grafana_dashboard gd ON gd.testid = test.id
                    WHERE gd.uid = grafana_dashboard_uid AND can_view(test.access, test.owner, test.token)
                ));
            CREATE POLICY grafana_panel_variable_policies ON grafana_panel_variable FOR ALL
                USING (exists(
                    SELECT 1 FROM test
                    JOIN grafana_dashboard gd ON gd.testid = test.id
                    JOIN grafana_panel gp ON gp.grafana_dashboard_uid = gd.uid
                    WHERE gp.id = grafana_panel_id AND can_view(test.access, test.owner, test.token)
                ));
        </sql>
    </changeSet>

    <changeSet id="8" author="rvansa">
        <sql>
            GRANT ALL ON SEQUENCE datapoint_id_seq TO "${quarkus.datasource.username}";
        </sql>
    </changeSet>

    <changeSet id="9" author="rvansa">
        <createProcedure>
            CREATE OR REPLACE FUNCTION to_double(v_input text)
            RETURNS double precision AS $$
            BEGIN
                BEGIN
                    RETURN v_input::double precision;
                EXCEPTION WHEN OTHERS THEN
                    RETURN NULL;
                END;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
    </changeSet>

    <changeSet id="10" author="rvansa">
        <addColumn tableName="variable">
            <column name="minwindow" type="integer" defaultValue="0"></column>
        </addColumn>
    </changeSet>

    <changeSet id="11" author="rvansa">
        <dropColumn tableName="variable">
            <column name="maxwindow" />
            <column name="confidence" />
            <column name="deviationfactor" />
        </dropColumn>
        <addColumn tableName="variable">
            <column name="maxdifferencelastdatapoint" type="double precision" defaultValue="0.05">
                <constraints nullable="false"/>
            </column>
            <column name="maxdifferencefloatingwindow" type="double precision" defaultValue="0.05">
                <constraints nullable="false"/>
            </column>
            <column name="floatingwindow" type="integer" defaultValue="7">
                <constraints nullable="false"/>
            </column>
        </addColumn>
    </changeSet>

    <changeSet id="12" author="rvansa">
        <addColumn tableName="test">
            <column name="tags" type="text" />
        </addColumn>
        <createTable tableName="run_tags">
            <column name="runid" type="integer">
                <constraints primaryKey="true" nullable="false" />
            </column>
            <column name="tags" type="jsonb" />
            <column name="extractor_ids" type="jsonb" />
        </createTable>
        <addForeignKeyConstraint constraintName="fk_run_tags_runid"
                                 baseTableName="run_tags" baseColumnNames="runid"
                                 referencedTableName="run" referencedColumnNames="id" />
        <sql>
            GRANT select, insert, delete ON TABLE run_tags TO "${quarkus.datasource.username}";
        </sql>
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_before_delete_test_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_tags WHERE runid IN (SELECT id FROM run WHERE testid = OLD.id);
                RETURN OLD;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_before_update_test_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_tags WHERE runid IN (SELECT id FROM run WHERE testid = OLD.id);
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_before_delete_run_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_tags WHERE runid = OLD.id;
                RETURN OLD;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <!-- We piggy-back on run_schemas -->
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_after_insert_run_schemas_func() RETURNS TRIGGER AS $$
            BEGIN
                WITH test_tags AS (
                    SELECT id AS testid, unnest(regexp_split_to_array(tags, ';')) AS accessor FROM test
                ), tags AS (
                    SELECT rs.runid, se.id as extractor_id, se.accessor, jsonb_path_query_first(run.data, (rs.prefix || se.jsonpath)::jsonpath) AS value
                        FROM schemaextractor se
                        JOIN test_tags ON se.accessor = test_tags.accessor
                        JOIN run_schemas rs ON rs.testid = test_tags.testid AND rs.schemaid = se.schema_id
                        JOIN run ON run.id = rs.runid
                        WHERE rs.runid = NEW.runid
                )
                INSERT INTO run_tags
                    SELECT tags.runid, jsonb_object_agg(tags.accessor, tags.value) AS tags, jsonb_agg(tags.extractor_id) AS extractor_ids FROM tags GROUP BY runid;
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_after_insert_test_func() RETURNS TRIGGER AS $$
            BEGIN
                WITH test_tags AS (
                    SELECT id AS testid, unnest(regexp_split_to_array(tags, ';')) AS accessor FROM test
                ), tags AS (
                    SELECT rs.runid, se.id AS extractor_id, se.accessor, jsonb_path_query_first(run.data, (rs.prefix || se.jsonpath)::jsonpath) AS value
                    FROM schemaextractor se
                    JOIN test_tags ON se.accessor = test_tags.accessor
                    JOIN run_schemas rs ON rs.testid = test_tags.testid AND rs.schemaid = se.schema_id
                    JOIN run ON run.id = rs.runid
                    WHERE rs.testid = NEW.id
                )
                INSERT INTO run_tags
                    SELECT tags.runid, jsonb_object_agg(tags.accessor, tags.value) AS tags, jsonb_agg(tags.extractor_id) AS extractor_ids FROM tags GROUP BY runid;
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_before_delete_extractor_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_tags WHERE OLD.id = ANY(extractor_ids);
                RETURN OLD;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_before_update_extractor_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_tags WHERE OLD.id = ANY(extractor_ids);
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_after_update_extractor_func() RETURNS TRIGGER AS $$
            BEGIN
                WITH test_tags AS (
                    SELECT id AS testid, unnest(regexp_split_to_array(tags, ';')) AS accessor FROM test
                ), matching_runs AS (
                    SELECT runid
                    FROM schemaextractor se
                    JOIN test_tags ON se.accessor = test_tags.accessor
                    JOIN run_schemas rs ON rs.testid = test_tags.testid AND rs.schemaid = se.schema_id
                    WHERE se.id = NEW.id
                ), tags AS (
                    SELECT rs.runid, se.id AS extractor_id, se.accessor, jsonb_path_query_first(run.data, (rs.prefix || se.jsonpath)::jsonpath) AS value
                    FROM schemaextractor se
                    JOIN test_tags ON se.accessor = test_tags.accessor
                    JOIN run_schemas rs ON rs.testid = test_tags.testid AND rs.schemaid = se.schema_id
                    JOIN run ON run.id = rs.runid
                    WHERE run.id = ANY(SELECT runid FROM matching_runs)
                )
                INSERT INTO run_tags
                    SELECT tags.runid, jsonb_object_agg(tags.accessor, tags.value) AS tags, jsonb_agg(tags.extractor_id) AS extractor_ids FROM tags GROUP BY runid;
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <sql>
            CREATE TRIGGER rt_before_delete BEFORE DELETE ON test FOR EACH ROW EXECUTE FUNCTION rt_before_delete_test_func();
            CREATE TRIGGER rt_before_update BEFORE UPDATE ON test FOR EACH ROW EXECUTE FUNCTION rt_before_update_test_func();
            CREATE TRIGGER rt_after_insert AFTER INSERT OR UPDATE ON test FOR EACH ROW EXECUTE FUNCTION rt_after_insert_test_func();
            CREATE TRIGGER rt_before_delete BEFORE DELETE ON run FOR EACH ROW EXECUTE FUNCTION rt_before_delete_run_func();
            CREATE TRIGGER rt_after_insert AFTER INSERT ON run_schemas FOR EACH ROW EXECUTE FUNCTION rt_after_insert_run_schemas_func();
            CREATE TRIGGER rt_before_delete BEFORE DELETE ON schemaextractor FOR EACH ROW EXECUTE FUNCTION rt_before_delete_extractor_func();
            CREATE TRIGGER rt_before_update BEFORE UPDATE ON schemaextractor FOR EACH ROW EXECUTE FUNCTION rt_before_delete_extractor_func();
            CREATE TRIGGER rt_after_update AFTER INSERT OR UPDATE ON schemaextractor FOR EACH ROW EXECUTE FUNCTION rt_after_update_extractor_func();
        </sql>
        <rollback>
            DROP TRIGGER IF EXISTS rt_before_delete ON test;
            DROP TRIGGER IF EXISTS rt_before_update ON test;
            DROP TRIGGER IF EXISTS rt_after_insert ON test;
            DROP TRIGGER IF EXISTS rt_before_delete ON run;
            DROP TRIGGER IF EXISTS rt_after_insert ON run_schemas;
            DROP TRIGGER IF EXISTS rt_before_delete ON schemaextractor;
            DROP TRIGGER IF EXISTS rt_before_update ON schemaextractor;
            DROP TRIGGER IF EXISTS rt_after_update ON schemaextractor;
        </rollback>
    </changeSet>

    <changeSet id="13" author="rvansa">
        <addColumn tableName="grafana_dashboard">
            <column name="tags" type="text" />
        </addColumn>
    </changeSet>

    <changeSet id="14" author="rvansa">
        <dropColumn tableName="run_tags" columnName="extractor_ids" />
        <addColumn tableName="run_tags">
            <column name="extractor_ids" type="int[]" />
        </addColumn>
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_after_insert_run_schemas_func() RETURNS TRIGGER AS $$
            BEGIN
                WITH test_tags AS (
                    SELECT id AS testid, unnest(regexp_split_to_array(tags, ';')) AS accessor FROM test
                ), tags AS (
                    SELECT rs.runid, se.id as extractor_id, se.accessor, jsonb_path_query_first(run.data, (rs.prefix || se.jsonpath)::jsonpath) AS value
                    FROM schemaextractor se
                    JOIN test_tags ON se.accessor = test_tags.accessor
                    JOIN run_schemas rs ON rs.testid = test_tags.testid AND rs.schemaid = se.schema_id
                    JOIN run ON run.id = rs.runid
                    WHERE rs.runid = NEW.runid
                )
                INSERT INTO run_tags
                    SELECT tags.runid, jsonb_object_agg(tags.accessor, tags.value) AS tags, array_agg(tags.extractor_id) AS extractor_ids FROM tags GROUP BY runid;
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_after_insert_test_func() RETURNS TRIGGER AS $$
            BEGIN
                WITH test_tags AS (
                    SELECT id AS testid, unnest(regexp_split_to_array(tags, ';')) AS accessor FROM test
                ), tags AS (
                    SELECT rs.runid, se.id AS extractor_id, se.accessor, jsonb_path_query_first(run.data, (rs.prefix || se.jsonpath)::jsonpath) AS value
                    FROM schemaextractor se
                    JOIN test_tags ON se.accessor = test_tags.accessor
                    JOIN run_schemas rs ON rs.testid = test_tags.testid AND rs.schemaid = se.schema_id
                    JOIN run ON run.id = rs.runid
                    WHERE rs.testid = NEW.id
                )
                INSERT INTO run_tags
                    SELECT tags.runid, jsonb_object_agg(tags.accessor, tags.value) AS tags, array_agg(tags.extractor_id) AS extractor_ids FROM tags GROUP BY runid;
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_after_update_extractor_func() RETURNS TRIGGER AS $$
            BEGIN
                WITH test_tags AS (
                    SELECT id AS testid, unnest(regexp_split_to_array(tags, ';')) AS accessor FROM test
                ), matching_runs AS (
                    SELECT runid
                    FROM schemaextractor se
                    JOIN test_tags ON se.accessor = test_tags.accessor
                    JOIN run_schemas rs ON rs.testid = test_tags.testid AND rs.schemaid = se.schema_id
                    WHERE se.id = NEW.id
                ), tags AS (
                    SELECT rs.runid, se.id AS extractor_id, se.accessor, jsonb_path_query_first(run.data, (rs.prefix || se.jsonpath)::jsonpath) AS value
                    FROM schemaextractor se
                    JOIN test_tags ON se.accessor = test_tags.accessor
                    JOIN run_schemas rs ON rs.testid = test_tags.testid AND rs.schemaid = se.schema_id
                    JOIN run ON run.id = rs.runid
                    WHERE run.id = ANY(SELECT runid FROM matching_runs)
                )
                INSERT INTO run_tags
                    SELECT tags.runid, jsonb_object_agg(tags.accessor, tags.value) AS tags, array_agg(tags.extractor_id) AS extractor_ids FROM tags GROUP BY runid;
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
    </changeSet>

    <changeSet id="15" author="rvansa">
        <sql>
            DROP TRIGGER rt_before_update ON schemaextractor;
            CREATE TRIGGER rt_before_update BEFORE UPDATE ON schemaextractor FOR EACH ROW EXECUTE FUNCTION rt_before_update_extractor_func();
        </sql>
    </changeSet>

    <changeSet id="16" author="rvansa">
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_before_insert_extractor_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_tags WHERE runid IN (SELECT runid FROM run_schemas WHERE run_schemas.schemaid = NEW.schema_id);
            RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <sql>
            CREATE TRIGGER rt_before_insert BEFORE INSERT ON schemaextractor FOR EACH ROW EXECUTE FUNCTION rt_before_insert_extractor_func();
        </sql>
    </changeSet>

    <changeSet id="17" author="rvansa">
        <createProcedure>
            CREATE OR REPLACE FUNCTION rt_before_delete_run_schemas_func() RETURNS TRIGGER AS $$
            BEGIN
                DELETE FROM run_tags WHERE run_tags.runid = OLD.runid;
                RETURN OLD;
            END;
            $$ LANGUAGE plpgsql;
        </createProcedure>
        <sql>
            CREATE TRIGGER rt_before_delete BEFORE DELETE ON run_schemas FOR EACH ROW EXECUTE FUNCTION rt_before_delete_run_schemas_func();
        </sql>
    </changeSet>

    <changeSet id="18" author="rvansa">
        <addColumn tableName="grafana_panel">
            <column name="name" type="text" />
        </addColumn>
    </changeSet>

    <changeSet id="19" author="rvansa">
        <createTable tableName="test_stalenesssettings">
            <column name="test_id" type="integer">
                <constraints nullable="false"/>
            </column>
            <column name="maxstaleness" type="bigint">
                <constraints nullable="false"/>
            </column>
            <column name="tags" type="jsonb" />
        </createTable>
        <addForeignKeyConstraint constraintName="fk_ss_test_id"
             baseTableName="test_stalenesssettings" baseColumnNames="test_id"
             referencedTableName="test" referencedColumnNames="id" />
        <createTable tableName="lastmissingrunnotification">
            <column name="id" type="bigint">
                <constraints primaryKey="true" nullable="false" />
            </column>
            <column name="lastnotification" type="timestamp without time zone"/>
            <column name="tags" type="jsonb"/>
            <column name="testid" type="integer">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <sql>
            GRANT select, insert, delete ON TABLE test_stalenesssettings TO "${quarkus.datasource.username}";
            GRANT select, insert, delete ON TABLE lastmissingrunnotification TO "${quarkus.datasource.username}";
            ALTER TABLE test_stalenesssettings ENABLE ROW LEVEL SECURITY;
            CREATE POLICY ss_select ON test_stalenesssettings FOR SELECT
                USING (exists(
                    SELECT 1 FROM test
                    WHERE test.id = test_id AND can_view(test.access, test.owner, test.token)
            ));
            CREATE POLICY ss_insert ON test_stalenesssettings FOR INSERT
                WITH CHECK (exists(
                    SELECT 1 FROM test
                    WHERE test.id = test_id AND has_role(test.owner)
            ));
            CREATE POLICY ss_update ON test_stalenesssettings FOR UPDATE
                USING (exists(
                    SELECT 1 FROM test
                    WHERE test.id = test_id AND has_role(test.owner)
                )) WITH CHECK (has_role('tester') AND exists(
                    SELECT 1 FROM test
                    WHERE test.id = test_id AND has_role(test.owner)
                ));
            CREATE POLICY ss_delete ON test_stalenesssettings FOR DELETE
                USING (has_role('tester') AND exists(
                    SELECT 1 FROM test
                    WHERE test.id = test_id AND has_role(test.owner)
            ));
            ALTER TABLE lastmissingrunnotification ENABLE ROW LEVEL SECURITY;
            CREATE POLICY lmrn_all ON lastmissingrunnotification FOR ALL
                USING (has_role('horreum.alerting'));
        </sql>
    </changeSet>
    <changeSet id="20" author="rvansa">
        <createTable tableName="calculationlog">
            <column name="id" type="bigint">
                <constraints primaryKey="true" nullable="false" />
            </column>
            <column name="level" type="integer">
                <constraints nullable="false" />
            </column>
            <column name="timestamp" type="timestamp without time zone">
                <constraints nullable="false" />
            </column>
            <column name="testid" type="integer" />
            <column name="runid" type="integer" />
            <column name="message" type="text">
                <constraints nullable="false" />
            </column>
        </createTable>
        <sql>
            GRANT select, insert, delete ON TABLE calculationlog TO "${quarkus.datasource.username}";
            ALTER TABLE calculationlog ENABLE ROW LEVEL SECURITY;
            CREATE POLICY cl_all ON calculationlog FOR ALL
                USING (has_role('horreum.alerting') OR (exists(
                    SELECT 1 FROM test
                    WHERE test.id = testid AND has_role(test.owner)
                ) AND exists(
                    SELECT 1 FROM run
                    WHERE run.id = runid AND has_role(run.owner)
                )));
        </sql>
    </changeSet>
    <changeSet id="21" author="rvansa">
        <sql>
            GRANT update ON TABLE test_stalenesssettings TO "${quarkus.datasource.username}";
            GRANT update ON TABLE lastmissingrunnotification TO "${quarkus.datasource.username}";
            GRANT update ON TABLE calculationlog TO "${quarkus.datasource.username}";
        </sql>
    </changeSet>
    <changeSet id="22" author="rvansa">
        <dropTable tableName="grafana_panel_variable"/>
        <dropTable tableName="grafana_panel"/>
        <dropTable tableName="grafana_dashboard"/>
    </changeSet>

    <changeSet id="23" author="rvansa">
        <addColumn tableName="test">
            <column name="notificationsenabled" type="boolean" defaultValue="true">
                <constraints nullable="false" />
            </column>
        </addColumn>
        <createProcedure>
            CREATE OR REPLACE FUNCTION can_view(access INTEGER, owner TEXT, token TEXT) RETURNS boolean AS $$
            BEGIN
                RETURN (
                    access = 0
                    OR (access = 1 AND has_role('viewer'))
                    OR (access = 2 AND has_role(owner) AND has_role('viewer'))
                    OR token = current_setting('horreum.token', true)
                    OR has_role('horreum.alerting')
                );
            END;
            $$ LANGUAGE plpgsql STABLE;
        </createProcedure>
    </changeSet>

    <changeSet id="24" author="rvansa">
        <createTable tableName="allowedhookprefix">
            <column name="id" type="bigint">
                <constraints primaryKey="true" nullable="false" />
            </column>
            <column name="prefix" type="text">
                <constraints nullable="false" />
            </column>
        </createTable>
        <!-- Only admin and test owners can both view and modify webhooks. -->
        <sql>
            GRANT SELECT, INSERT, DELETE, UPDATE ON TABLE allowedhookprefix TO "${quarkus.datasource.username}";
            ALTER TABLE allowedhookprefix ENABLE ROW LEVEL SECURITY;
            CREATE POLICY prefix_select ON allowedhookprefix FOR SELECT USING(true);
            CREATE POLICY prefix_insert ON allowedhookprefix FOR INSERT WITH CHECK (has_role('admin'));
            CREATE POLICY prefix_update ON allowedhookprefix FOR UPDATE USING (has_role('admin'));
            CREATE POLICY prefix_delete ON allowedhookprefix FOR DELETE USING (has_role('admin'));

            ALTER TABLE hook ENABLE ROW LEVEL SECURITY;
            CREATE POLICY hook_policies ON hook
                USING (has_role('admin') OR exists(
                    SELECT 1 FROM test WHERE (type = 'change/new' OR type = 'run/new') AND target = test.id AND can_view(test.access, test.owner, test.token)
                ));
            CREATE POLICY hook_write_check ON hook
                WITH CHECK (exists(SELECT 1 FROM allowedhookprefix ahp WHERE left(url, length(ahp.prefix)) = ahp.prefix));
        </sql>
    </changeSet>

    <changeSet id="25" author="rvansa">
        <createTable tableName="test_token">
            <column name="id" type="integer">
                <constraints nullable="false" primaryKey="true"/>
            </column>
            <column name="test_id" type="integer">
                <constraints nullable="false"/>
            </column>
            <column name="value" type="text">
                <constraints nullable="false" />
            </column>
            <column name="permissions" type="integer">
                <constraints nullable="false" />
            </column>
            <column name="description" type="text">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint constraintName="fk_token_test_id"
                                 baseTableName="test_token" baseColumnNames="test_id"
                                 referencedTableName="test" referencedColumnNames="id" />
        <sql>
            DROP POLICY view_select ON view;
            DROP POLICY vc_select ON viewcomponent;
            DROP POLICY variable_select ON variable;
            DROP POLICY ss_select ON test_stalenesssettings;
            DROP POLICY hook_policies ON hook;
            DROP POLICY test_select ON TEST;
        </sql>
        <dropColumn tableName="test" columnName="token" />
        <createProcedure>
            CREATE OR REPLACE FUNCTION has_role2(owner TEXT, type TEXT) RETURNS boolean AS $$
            BEGIN
                RETURN (right(owner, 4) = 'team' AND has_role(left(owner, -4) || type));
            END;
            $$ LANGUAGE plpgsql STABLE;
        </createProcedure>
        <createProcedure>
            CREATE OR REPLACE FUNCTION can_view2(access INTEGER, owner TEXT) RETURNS boolean AS $$
            BEGIN
                RETURN (
                    access = 0
                    OR (access = 1 AND has_role('viewer'))
                    OR (access = 2 AND has_role(owner) AND has_role('viewer'))
                );
            END;
            $$ LANGUAGE plpgsql STABLE;
        </createProcedure>
        <createProcedure>
            -- this function is a security definer and as such avoids regular policies on test_token
            CREATE OR REPLACE FUNCTION has_read_token(testid INTEGER) RETURNS boolean AS $$
            BEGIN
                RETURN (exists(
                    SELECT 1 FROM test_token
                    WHERE test_id = testid AND (permissions &amp; 1) != 0 AND value = current_setting('horreum.token', true)
                ));
            END;
            $$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
        </createProcedure>
        <createProcedure>
            -- this function is a security definer and as such avoids regular policies on test_token
            CREATE OR REPLACE FUNCTION has_modify_token(testid INTEGER) RETURNS boolean AS $$
            BEGIN
                RETURN (exists(
                    SELECT 1 FROM test_token
                    WHERE test_id = testid AND (permissions &amp; 2) != 0 AND value = current_setting('horreum.token', true)
                ));
            END;
            $$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
        </createProcedure>
        <createProcedure>
            -- this function is a security definer and as such avoids regular policies on test_token
            CREATE OR REPLACE FUNCTION has_upload_token(testid INTEGER) RETURNS boolean AS $$
            BEGIN
                RETURN (exists(
                    SELECT 1 FROM test_token
                    WHERE test_id = testid AND (permissions &amp; 4) != 0 AND value = current_setting('horreum.token', true)
                ));
            END;
            $$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
        </createProcedure>
        <sql>
            GRANT SELECT, INSERT, DELETE, UPDATE ON TABLE test_token TO "${quarkus.datasource.username}";
            ALTER TABLE test_token ENABLE ROW LEVEL SECURITY;
            CREATE POLICY token_policy ON test_token
                USING (has_role2((SELECT owner FROM test WHERE test.id = test_id), 'tester'));
        </sql>
        <sql>
            -- run_select unchanged
            DROP POLICY run_insert ON run;
            CREATE POLICY run_insert ON run FOR INSERT
                WITH CHECK (has_role2(owner, 'uploader') OR has_upload_token(testid));
            DROP POLICY run_update ON run;
            CREATE POLICY run_update ON run FOR UPDATE
                USING (has_role2(owner, 'tester'));
            DROP POLICY run_delete ON run;
            -- Testers update runs' trashed flag but never really delete these
            CREATE POLICY run_delete ON run FOR DELETE
                USING (has_role('horreum.system'));
        </sql>
        <sql>
            CREATE POLICY test_select ON test FOR SELECT
                USING (can_view2(access, owner) OR has_read_token(id));
            DROP POLICY test_insert ON test;
            CREATE POLICY test_insert ON test FOR INSERT
                WITH CHECK (has_role2(owner, 'tester'));
            DROP POLICY test_update ON test;
            CREATE POLICY test_update ON test FOR UPDATE
                USING (has_role2(owner, 'tester') OR has_modify_token(id));
            DROP POLICY test_delete ON test;
            CREATE POLICY test_delete ON test FOR DELETE
                USING (has_role2(owner, 'tester') OR has_modify_token(id));
        </sql>
        <sql>
            -- schema_select unchanged
            DROP POLICY schema_insert ON schema;
            CREATE POLICY schema_insert ON schema FOR INSERT
                WITH CHECK (has_role2(owner, 'tester'));
            DROP POLICY schema_update ON schema;
            CREATE POLICY schema_update ON schema FOR UPDATE
                USING (has_role2(owner, 'tester'));
            DROP POLICY schema_delete ON schema;
            CREATE POLICY schema_delete ON schema FOR DELETE
                USING (has_role2(owner, 'tester'));
        </sql>
        <sql>
            DROP POLICY hook_policy ON hook;
            CREATE POLICY hook_policy ON hook
                USING (has_role('admin') OR (
                    (type = 'change/new' OR type = 'run/new')
                    AND (
                        has_role2((SELECT owner FROM test WHERE test.id = target), 'tester')
                        OR has_modify_token(target)
                    )
                ));
            DROP POLICY hook_write_check ON hook;
            CREATE POLICY hook_write_check ON hook AS RESTRICTIVE
                WITH CHECK (exists(SELECT 1 FROM allowedhookprefix ahp WHERE left(url, length(ahp.prefix)) = ahp.prefix));
        </sql>
        <sql>
            -- se_select unchanged
            DROP POLICY se_insert ON schemaextractor;
            CREATE POLICY se_insert ON schemaextractor FOR INSERT
                WITH CHECK (has_role2((SELECT owner FROM schema WHERE schema.id = schema_id), 'tester'));
            DROP POLICY se_update ON schemaextractor;
            CREATE POLICY se_update ON schemaextractor FOR UPDATE
                USING (has_role2((SELECT owner FROM schema WHERE schema.id = schema_id), 'tester'));
            DROP POLICY se_delete ON schemaextractor;
            CREATE POLICY se_delete ON schemaextractor FOR DELETE
                USING (has_role2((SELECT owner FROM schema WHERE schema.id = schema_id), 'tester'));
        </sql>
        <sql>
            CREATE POLICY view_select ON view FOR SELECT
                USING (exists(
                    SELECT 1 FROM test WHERE test.id = test_id AND can_view2(test.access, test.owner)
                ) OR has_read_token(test_id));
            DROP POLICY view_insert ON view;
            CREATE POLICY view_insert ON view FOR INSERT
                WITH CHECK (has_role2((SELECT owner FROM test WHERE test.id = test_id), 'tester') OR has_modify_token(test_id));
            DROP POLICY view_update ON view;
            CREATE POLICY view_update ON view FOR UPDATE
                USING (has_role2((SELECT owner FROM test WHERE test.id = test_id), 'tester') OR has_modify_token(test_id));
            DROP POLICY view_delete ON view;
            CREATE POLICY view_delete ON view FOR DELETE
                USING (has_role2((SELECT owner FROM test WHERE test.id = test_id), 'tester') OR has_modify_token(test_id));
        </sql>
        <sql>
            CREATE POLICY vc_select ON viewcomponent FOR SELECT
                USING (exists(
                    SELECT 1 FROM test
                    JOIN view ON view.test_id = test.id
                    WHERE view.id = view_id AND (can_view2(test.access, test.owner) OR has_read_token(test.id))
                ));
            DROP POLICY vc_insert ON viewcomponent;
            CREATE POLICY vc_insert ON viewcomponent FOR INSERT
                WITH CHECK (exists(
                    SELECT 1 FROM test
                    JOIN view ON view.test_id = test.id
                    WHERE view.id = view_id AND (has_role2(test.owner, 'tester') OR has_modify_token(test.id))
                ));
            DROP POLICY vc_update ON viewcomponent;
            CREATE POLICY vc_update ON viewcomponent FOR UPDATE
                USING (exists(
                    SELECT 1 FROM test
                    JOIN view ON view.test_id = test.id
                    WHERE view.id = view_id AND (has_role2(test.owner, 'tester') OR has_modify_token(test.id))
                ));
            DROP POLICY vc_delete ON viewcomponent;
            CREATE POLICY vc_delete ON viewcomponent FOR DELETE
                USING (exists(
                    SELECT 1 FROM test
                    JOIN view ON view.test_id = test.id
                    WHERE view.id = view_id AND (has_role2(test.owner, 'tester') OR has_modify_token(test.id))
                ));
        </sql>
        <sql>
            -- rs_select unchanged
            DROP POLICY rs_insert ON run_schemas;
            CREATE POLICY rs_insert ON run_schemas FOR INSERT
                WITH CHECK (
                    has_role2((SELECT owner FROM run WHERE run.id = runid), 'uploader')
                    OR has_upload_token(testid)
                    OR has_role2((SELECT owner FROM schema WHERE schema.id = schemaid), 'tester')
                );
            -- This policy is here to prevent rogue records. However since the schema owner has access
            -- it can claim that certain run is using his schema even if it is not.
            CREATE POLICY rs_insert_validate ON run_schemas AS RESTRICTIVE FOR INSERT
                WITH CHECK (exists(SELECT 1 FROM run WHERE run.id = runid AND run.testid = testid));
            DROP POLICY rs_update ON run_schemas;
            -- run_schemas are never updated, just dropped and inserted
            DROP POLICY rs_delete ON run_schemas;
            -- both run update and schema update/delete should drop the row; privilege to any of those is sufficient to remove the record
            -- though deleting a schema with matching rows isn
            -- horreum.system can delete the run
            CREATE POLICY rs_delete ON run_schemas FOR DELETE
                USING (
                    has_role('horreum.system')
                    OR has_role2((SELECT owner FROM run WHERE run.id = runid), 'tester')
                    OR has_role2((SELECT owner FROM schema WHERE schema.id = schemaid), 'tester')
                );
        </sql>
        <sql>
            -- vd_select unchanged
            DROP POLICY vd_insert ON view_data;
            CREATE POLICY vd_insert ON view_data FOR INSERT
                WITH CHECK (exists(
                    SELECT 1 FROM run
                    JOIN test ON test.id = run.testid
                    WHERE run.id = runid AND (has_role2(run.owner, 'uploader') OR has_role2(test.owner, 'tester') OR has_upload_token(test.id))
                ) OR exists (
                    SELECT 1 FROM schema
                    JOIN schemaextractor se ON se.schema_id = schema.id
                    WHERE se.id = ANY(extractor_ids) AND has_role2(schema.owner, 'tester')
                ));
            DROP POLICY vd_update ON view_data;
            -- view_data is never updated
            DROP POLICY vd_delete ON view_data;
            CREATE POLICY vd_delete ON view_data FOR DELETE
                USING (has_role('horreum.system') OR exists(
                    SELECT 1 FROM run
                    JOIN test ON test.id = run.testid
                    WHERE run.id = runid AND (has_role2(run.owner, 'tester') OR has_role2(test.owner, 'tester'))
                ) OR exists(
                    SELECT 1 FROM schema
                    JOIN schemaextractor se ON se.schema_id = schema.id
                    WHERE se.id = ANY(extractor_ids) AND has_role2(schema.owner, 'tester')
                ));
        </sql>
        <sql>
            -- change_select unchanged
            DROP POLICY change_insert ON change;
            -- only alerting can create changes
            CREATE POLICY change_insert ON change FOR INSERT
                WITH CHECK (has_role('horreum.alerting'));
            DROP POLICY change_update ON change;
            CREATE POLICY change_update ON change FOR UPDATE
                USING (has_role2((SELECT owner FROM run WHERE run.id = runid), 'tester'));
            DROP POLICY change_delete ON change;
            CREATE POLICY change_delete ON change FOR DELETE
                USING (has_role2((SELECT owner FROM run WHERE run.id = runid), 'tester'));
        </sql>
        <sql>
            -- The user deletes datapoints when changing test variables
            DROP POLICY datapoint_delete ON datapoint;
            CREATE POLICY datapoint_delete ON datapoint FOR DELETE
                USING (has_role('horreum.alerting') OR has_role2((SELECT owner FROM run WHERE run.id = runid), 'tester'));
        </sql>
        <sql>
            CREATE POLICY variable_access ON variable USING (has_role('horreum.alerting'));
            CREATE POLICY variable_select ON variable FOR SELECT
                USING (
                    exists(SELECT 1 FROM test WHERE test.id = testid AND can_view2(test.access, test.owner))
                    OR has_read_token(testid)
                );
            DROP POLICY variable_insert ON variable;
            CREATE POLICY variable_insert ON variable FOR INSERT
                WITH CHECK (
                    has_role2((SELECT owner FROM test WHERE test.id = testid), 'tester')
                    OR has_modify_token(testid)
                );
            DROP POLICY variable_update ON variable;
            CREATE POLICY variable_update ON variable FOR UPDATE
                USING (
                    has_role2((SELECT owner FROM test WHERE test.id = testid), 'tester')
                    OR has_modify_token(testid)
                );
            DROP POLICY variable_delete ON variable;
            CREATE POLICY variable_delete ON variable FOR DELETE
                USING (
                    has_role2((SELECT owner FROM test WHERE test.id = testid), 'tester')
                    OR has_modify_token(testid)
                );
        </sql>
        <sql>
            CREATE POLICY ss_select ON test_stalenesssettings FOR SELECT
                USING (
                    exists(SELECT 1 FROM test WHERE test.id = test_id AND can_view2(test.access, test.owner))
                    OR has_read_token(test_id)
                );
            DROP POLICY ss_insert ON test_stalenesssettings;
            CREATE POLICY ss_insert ON test_stalenesssettings FOR INSERT
                WITH CHECK (
                    has_role2((SELECT owner FROM test WHERE test.id = test_id), 'tester')
                    OR has_modify_token(test_id)
                );
            DROP POLICY ss_update ON test_stalenesssettings;
            CREATE POLICY ss_update ON test_stalenesssettings FOR UPDATE
                USING (
                    has_role2((SELECT owner FROM test WHERE test.id = test_id), 'tester')
                    OR has_modify_token(test_id)
                );
            DROP POLICY ss_delete ON test_stalenesssettings;
            CREATE POLICY ss_delete ON test_stalenesssettings FOR DELETE
                USING (
                    has_role2((SELECT owner FROM test WHERE test.id = test_id), 'tester')
                    OR has_modify_token(test_id)
                );
        </sql>
        <sql>
            DROP POLICY cl_all ON calculationlog;
            CREATE POLICY cl_all_alerting ON calculationlog USING (has_role('horreum.alerting'));
            CREATE POLICY cl_all ON calculationlog FOR ALL
                USING ((
                    (has_role2((SELECT owner FROM test WHERE test.id = testid), 'tester')
                    OR has_modify_token(testid))
                ) AND has_role2((SELECT owner FROM run WHERE run.id = runid), 'tester'));
        </sql>
    </changeSet>

    <changeSet id="26" author="rvansa">
        <dropColumn tableName="schema" columnName="testpath" />
        <dropColumn tableName="schema" columnName="startpath" />
        <dropColumn tableName="schema" columnName="stoppath" />
        <dropColumn tableName="schema" columnName="descriptionpath" />
    </changeSet>
</databaseChangeLog>

